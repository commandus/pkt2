syntax = "proto3";

package iridium;

import "pkt2.proto";

/*
typedef ALIGN struct
{
	uint8_t latitude_g;	    // 0	    [3](0-90)	добавить бит N or S 0х80 (0х80 - данные корректны)
	uint8_t latitude_m;	    // 1        [4](0-60)	или добавить бит N or S 0х80, E or W (East or West) 0х40
	//unsigned long int latitude_s;       //3  (6 bytes (48 bit) число до 281 474 976 710 656) size=32
	uint16_t latitude_s;	// 2-3      [5-6] 2 байта
	//   unsigned long ?? size =   long int 32 -2147483648 to 2147483647    unsigned long int size=32 0 to 4 294 967 295
	uint16_t latitude_s1;	// 4-5      [7-8]7 reserved
	uint8_t latitude_ns;	// 6 N/S    [9]   0x4E или 0x53
	uint8_t longitude_g;	// 7(0-180) [10]
	uint8_t longitude_m;	// 8(0-60)  [11]
	//unsigned long int longitude_s;     //11  (6 bytes (48 bit) число до 281 474 976 710 656) unsigned long int size=32
	uint16_t longitude_s;	// 9-10      [12-13]
	uint16_t longitude_s1;	// 11-12     [14-15]
	uint8_t longitude_ew;	// 13 E or W    0x45 или 0x57
	uint8_t hdop;		    // 14 HDOP, m, 0-99
	uint8_t pdop;	        // 15 PDOP, m, 0-99
} PACKED gps_coord_t;
*/
message GPS_Coordinates
{
    // input packet
    option(pkt2.packet) = { 
        name: "gpc_coord"
        short_name: "Координаты GPS"
        full_name: "Координаты GPS приемника"
        fields: [
        {
            name: "latitude_g"
            type: INPUT_UINT
            size: 1
            offset: 0
        },
        {
            name: "latitude_m"
            type: INPUT_UINT
            size: 1
            offset: 1
        },
        {
            name: "latitude_s"
            type: INPUT_UINT
            size: 2
            offset: 2
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "latitude_s1"
            type: INPUT_UINT
            size: 2
            offset: 4
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "latitude_ew"
            type: INPUT_UINT
            size: 1
            offset: 6
        },
        
        {
            name: "longitude_g"
            type: INPUT_UINT
            size: 1
            offset: 7
        },
        {
            name: "longitude_m"
            type: INPUT_UINT
            size: 1
            offset: 8
        },
        {
            name: "longitude_s"
            type: INPUT_UINT
            size: 2
            offset: 9
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "longitude_s1"
            type: INPUT_UINT
            size: 2
            offset: 11
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "longitude_ns"
            type: INPUT_UINT
            size: 1
            offset: 13
        },

        {
            name: "h_dop"
            type: INPUT_UINT
            size: 1
            offset: 14
        },
        {
            name: "p_dop"
            type: INPUT_UINT
            size: 1
            offset: 15
        }]
    };
    
    // output
    double latitude = 1 [(pkt2.variable) = {
        name: "latitude"
        short_name: "Широта"
        full_name: "Широта, градус"
        measure_unit: "°"
        formula: "(latitude_ns == 'S' ? -1. : 1.) * (latitude_g + ((latitude_m + ((latitude_s > 9999 ? 9999 : latitude_s) * 0.0001)) / 60.))"
        priority: 0
        format: "%10.6f"
    }];
    
    double longitude = 2 [(pkt2.variable) = {
        name: "longitude"
        short_name: "Долгота"
        full_name: "Долгота, градус"
        measure_unit: "°"
        formula: "(longitude_ns == 'W' ? -1. : 1.) * (longitude_g + ((longitude_m + ((longitude_s > 9999 ? 9999 : longitude_s) * 0.0001)) / 60.))"
        priority: 0
        format: "%10.6f"
    }];

    uint32 hdop = 3 [(pkt2.variable) = {
        name: "HDOP"
        short_name: "HDOP"
        full_name: "HDOP, m"
        measure_unit: "m"
        formula: "h_dop"
        priority: 0
    }];
    
    uint32 pdop = 4 [(pkt2.variable) = {
        name: "PDOP"
        short_name: "PDOP"
        full_name: "PDOP, m"
        measure_unit: "m"
        formula: "p_dop"
        priority: 0
    }];
}

/*
// 5 bytes time
// 2 байта год/месяц/день
//	7 бит год           0b xxxx xxx0
//	4 бита месяц        0b x xxx0 0000
//	5 бит день          0b 000x xxxx
typedef ALIGN struct {
	uint16_t day: 5;
	uint16_t month: 4;
	uint16_t year: 7;

	uint8_t hour;
	uint8_t minute;
	uint8_t second;
} PACKED time5;
*/
message Time5
{
	// input packet
    option(pkt2.packet) = { 
        name: "time5"
        short_name: "Время"
        full_name: "Дата и время"
        fields: [
        {
            name: "day_month_year"
            type: INPUT_UINT
            size: 2
            offset: 0
        },
        {
            name: "hour"
            type: INPUT_UINT
            size: 1
            offset: 2
        },
        {
            name: "minute"
            type: INPUT_UINT
            size: 1
            offset: 3
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "second"
            type: INPUT_UINT
            size: 1
            offset: 4
            endian: ENDIAN_BIG_ENDIAN
        }]
    };
    
    // output
    uint32 date_time = 1 [(pkt2.variable) = {
        name: "latitude"
        short_name: "Широта"
        full_name: "Широта, градус"
        measure_unit: "°"
        formula: "struct tm info; \
            info.tm_year = (day_month_year & ((1 << 7) - 1)) + 2000 - 1900; \
			info.tm_mon = (day_month_year >> 7) & ((1 << 4) - 1) - 1; \
			info.tm_mday = (day_month_year >> (7 + 4)) & ((1 << 5) - 1); \
			info.tm_hour = hour; \
			info.tm_min = minute; \
			info.tm_sec = second; \
			info.tm_isdst = -1; \
			RETURN_VALUE = mktime(&info);" 
        priority: 0
        tostring: "char f[30];
            struct tm = localtime(&INPUT_VALUE);
        	strftime(f, sizeof(f), \"T %Y-%m-%d\", &tm);
        	RETURN_VALUE = f;"
        format: "%d"
    }];
}

/*
typedef ALIGN struct {
	uint8_t packettype;		    //< 0) 1 байт 0х08 - координаты с NMEA приемников LAT, LON,
	uint8_t gpsolddata:1;		//< 1)GPS old data, GPS not read
	uint8_t gpsencoded:1;		//< GPS data encoded
	uint8_t gpsfrommemory:1;	//< data got from the memory
	uint8_t gpsnoformat:1;		//< memory is not formatted
	uint8_t gpsnosats:1;		//< No visible GPS salellites
	uint8_t gpsbadhdop:1;		//< GPS HDOP = 99 or > 50
	uint8_t gpstime:1;		    //< 1 бит 1-0  GPS.valid=0x01 или 0;     GPS.time_valid=0b0000 0010 или 0;
	uint8_t gpsnavdata:1;		//< 1 бит 1-0  GPS.valid=0x01 или 0;     GPS.time_valid=0b0000 0010 или 0;
	uint8_t sats;		        //< 2) 1 байт  кол. видимых спутников
	gps_coord_t coord;		    //< 3) 16 байт (или 10 байт??? ) hex ?
	uint8_t bat:6;			    //< 19) байт бортовое напряжение fixed point (32=3.2 вольта) (от 2.0 до 4.0)
	uint8_t alarmlow:1;	        //< bit 6 < 2V, bit 7 > 4V
	uint8_t alarmhigh:1;		//< bit 6 < 2V, bit 7 > 4V
	int8_t temperature;	        //< 20) 1 байт температура
	uint8_t r2;			        //< 21) 1 байт номер пакета?? - он же индекс в таблице кодировки
	uint8_t failurepower:1;		//< 22) device status power loss
	uint8_t failureeep:1;		//< EEPROM failure
	uint8_t failureclock:1;		//< clock not responding
	uint8_t failurecable:1;		//< MAC not responding
	uint8_t failureint0:1;		//< clock int failure
	uint8_t failurewatchdog:1;	//< software failure
	uint8_t failurenoise:1;		//< blocks in memory found
	uint8_t failureworking:1;	//< device was
	uint16_t key;			    // 23) 2 байт     volatile unsigned int packet_key;  младшие 16 бит
	// uint8_t		 res[3];
	time5 time;                 // 25 5 байт
	// uint32_t crc;
} PACKED packet8_t;
*/
/// A lot of flags
message Packet8
{
    // backend database
    option(pkt2.output) = {
    	sql {
    		dialect: SQL_POSTGRESQL
    	}
    };

    // input packet description
    option(pkt2.packet) = { 
        name: "animal"
        short_name: "Животные"
        full_name: "Животные"
        source: {
            proto: PROTO_TCP
            address: "84.237.104.57"
            port: 0 // any port
        }
        fields: [
        {
            name: "packet_type"
            type: INPUT_UINT
            size: 1
            offset: 0
        },
        {
            name: "gps_flags"
            type: INPUT_UINT
            size: 1
            offset: 1
        },
        {
            name: "sats"
            type: INPUT_UINT
            size: 1
            offset: 1
        },
        {
            name: "gps_coords"
            type: INPUT_BYTES
            size: 16
            offset: 3
        },
        {
            name: "battery"
            type: INPUT_UINT
            size: 1
            offset: 19
        },
        {
            name: "temperature"
            type: INPUT_INT
            size: 1
            offset: 20
        },
        {
            name: "r2"
            type: INPUT_UINT
            size: 1
            offset: 21
        },
        {
            name: "failure_flags"
            type: INPUT_UINT
            size: 1
            offset: 22
        },
        {
            name: "packet_key"
            type: INPUT_UINT
            size: 2
            offset: 23
            endian: ENDIAN_BIG_ENDIAN
        },
        {
            name: "time5"
            type: INPUT_BYTES
            size: 5
            offset: 25
        }
        ]
    };

	// structure 16 bytes long (bytes 3..18) 
    GPS_Coordinates coordinates = 1 [(pkt2.variable) = {
        field: "gps_coords"
        name: "gps_coordinates"
        short_name: "Координаты"
        full_name: "Географические координаты GPS приемника"
    }];

	// structure 5 bytes long (bytes 25..30) 
    Time5 measure_time = 2 [(pkt2.variable) = {
        field: "time5"
        name: "measure_time"
        short_name: "Время"
        full_name: "Время получения данных"
    }];

    // output 
    bool gpsolddata = 3 [(pkt2.variable) = {
        name: "gpsolddata"
        short_name: "GPS old data"
        formula: "gps_flags & (1 << 0)"
    }];

    bool gpsencoded = 4 [(pkt2.variable) = {
        name: "gpsencoded"
        short_name: "GPS data encoded"
        formula: "(gps_flags & (1 << 1))"
    }];

    bool gpsfrommemory = 5 [(pkt2.variable) = {
        name: "gpsfrommemory"
        short_name: "data got from the memory"
        formula: "(gps_flags & (1 << 2))"
    }];
    
    bool gpsnoformat = 6 [(pkt2.variable) = {
        name: "gpsfrommemory"
        short_name: "memory is not formatted"
        formula: "(gps_flags & (1 << 3))"
    }];
    
    bool gpsnosats = 7 [(pkt2.variable) = {
        name: "gpsfrommemory"
        short_name: "No visible GPS salellites"
        formula: "(gps_flags & (1 << 4))"
    }];

    bool gpsbadhdop = 8 [(pkt2.variable) = {
        name: "gpsbadhdop"
        short_name: "GPS HDOP = 99 or > 50"
        formula: "(gps_flags & (1 << 6))"
    }];

    bool gpstime = 9 [(pkt2.variable) = {
        name: "gpstime"
        short_name: "GPS.valid"
        formula: "(gps_flags & (1 << 7))"
    }];

    bool gpsnavdata = 10 [(pkt2.variable) = {
        name: "gpsnavdata"
        short_name: "time valid"
        formula: "(gps_flags & (1 << 8))"
    }];
    
    bool satellite_visible_count = 11 [(pkt2.variable) = {
        name: "satellite_visible_count"
        short_name: "Видимых спутников"
        formula: "sats"
    }];
    
	float battery_voltage = 12 [(pkt2.variable) = {
        name: "battery_voltage"
        short_name: "бортовое напряжение"
        formula: "(battery & 0x3f) / 10."
    }];
    
	bool battery_low = 13 [(pkt2.variable) = {
        name: "battery_low"
        short_name: "низкое бортовое напряжение"
        formula: "battery & 0x40"
    }];

	bool battery_low = 14 [(pkt2.variable) = {
        name: "battery_low"
        short_name: "высокое бортовое напряжение"
        formula: "battery & 0x80"
    }];

	int32 temperature = 15 [(pkt2.variable) = {
        name: "temperature_c"
        short_name: "бортовая температура"
        formula: "temperature"
        measure_unit: "C"
    }];
	
	int32 reserved_2 = 15 [(pkt2.variable) = {
        name: "reserved_2"
        formula: "r2"
    }];

	bool failurepower = 14 [(pkt2.variable) = {
        name: "failurepower"
        short_name: "device status power loss"
        formula: "failure_flags & (1 << 0)"
    }];
	
	bool failureeep = 14 [(pkt2.variable) = {
        name: "failureeep"
        short_name: "EEPROM failure"
        formula: "failure_flags & (1 << 1)"
    }];

	bool failureeep = 14 [(pkt2.variable) = {
        name: "failureeep"
        short_name: "clock not responding"
        formula: "failure_flags & (1 << 2)"
    }];

	bool failurecable = 14 [(pkt2.variable) = {
        name: "failurecable"
        short_name: "MAC not responding"
        formula: "failure_flags & (1 << 3)"
    }];

	bool failureint0 = 14 [(pkt2.variable) = {
        name: "failureint0"
        short_name: "clock int failure"
        formula: "failure_flags & (1 << 4)"
    }];

	bool software_failure = 14 [(pkt2.variable) = {
        name: "software_failure"
        short_name: "software failure"
        formula: "failure_flags & (1 << 5)"
    }];

	bool failurewatchdog = 14 [(pkt2.variable) = {
        name: "failurewatchdog"
        short_name: "failure watchdog"
        formula: "failure_flags & (1 << 6)"
    }];
    
    bool failurenoise = 14 [(pkt2.variable) = {
        name: "failurenoise"
        short_name: "blocks in memory found"
        formula: "failure_flags & (1 << 7)"
    }];
    
    bool failureworking = 14 [(pkt2.variable) = {
        name: "failureworking"
        short_name: "failure working"
        formula: "failure_flags & (1 << 8)"
    }];

	uint32 key = 15 [(pkt2.variable) = {
        name: "key"
        formula: "packet_key"
    }];
}
